#
#  SuperTux -nogl patch
#  Copyright (C) 2006 Christoph Sommer <christoph.sommer@2006.expires.deltadevelopment.de>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# -----------------------------------------------------------------------------
#
#  This patch allows running the game on systems without OpenGL support. 
#
#  It modifies the video portion of the SuperTux engine to render all graphics
#  with SDL functions only. Many features are removed from the video engine,
#  so don't expect much.
#
#  Installing the patch should be pretty straightforward. Simply run the
#  following command prior to running autogen.sh and configure:
#
#  patch -p0 < contrib/supertux-nogl.diff
#
#  This patch works for revision 5068. It may break for later revisions.
#
# -----------------------------------------------------------------------------
Index: src/gameconfig.hpp
===================================================================
--- src/gameconfig.hpp	(revision 5067)
+++ src/gameconfig.hpp	(working copy)
@@ -39,6 +39,7 @@
   float aspect_ratio;
 
   bool use_fullscreen;
+  bool use_opengl;
   bool try_vsync;
   bool show_fps;
   bool sound_enabled;
Index: src/video/drawing_context.cpp
===================================================================
--- src/video/drawing_context.cpp	(revision 5067)
+++ src/video/drawing_context.cpp	(working copy)
@@ -308,28 +308,38 @@
 void
 DrawingContext::get_light(const Vector& position, Color* color)
 {
-  if( ambient_color.red == 1.0f && ambient_color.green == 1.0f
-      && ambient_color.blue  == 1.0f ) {
-    *color = Color( 1.0f, 1.0f, 1.0f);
-    return;
-  }
+  if(config->use_opengl) {
+    if( ambient_color.red == 1.0f && ambient_color.green == 1.0f
+        && ambient_color.blue  == 1.0f ) {
+      *color = Color( 1.0f, 1.0f, 1.0f);
+      return;
+    }
 
-  DrawingRequest* request = new(obst) DrawingRequest();
-  request->type = GETLIGHT;
-  request->pos = transform.apply(position);
+    DrawingRequest* request = new(obst) DrawingRequest();
+    request->type = GETLIGHT;
+    request->pos = transform.apply(position);
 
-  //There is no light offscreen.
-  if(request->pos.x >= SCREEN_WIDTH || request->pos.y >= SCREEN_HEIGHT
-      || request->pos.x < 0 || request->pos.y < 0){
-    *color = Color( 0, 0, 0);
-    return;
+    //There is no light offscreen.
+    if(request->pos.x >= SCREEN_WIDTH || request->pos.y >= SCREEN_HEIGHT
+        || request->pos.x < 0 || request->pos.y < 0){
+      *color = Color( 0, 0, 0);
+      return;
+    }
+
+    request->layer = LAYER_GUI; //make sure all get_light requests are handled last.
+    GetLightRequest* getlightrequest = new(obst) GetLightRequest();
+    getlightrequest->color_ptr = color;
+    request->request_data = getlightrequest;
+    lightmap_requests.push_back(request);
+  } else {
+    static int i = 0;
+    i += 1; i &= 0xFFFF;
+    if (i & 0x8000) {
+      *color = Color(0.0f, 0.0f, 0.0f);
+    } else {
+      *color = Color(1.0f, 1.0f, 1.0f);
+    }
   }
-
-  request->layer = LAYER_GUI; //make sure all get_light requests are handled last.
-  GetLightRequest* getlightrequest = new(obst) GetLightRequest();
-  getlightrequest->color_ptr = color;
-  request->request_data = getlightrequest;
-  lightmap_requests.push_back(request);
 }
 
 void
@@ -370,16 +380,47 @@
   const Color& top = gradientrequest->top;
   const Color& bottom = gradientrequest->bottom;
 
-  glDisable(GL_TEXTURE_2D);
-  glBegin(GL_QUADS);
-  glColor4f(top.red, top.green, top.blue, top.alpha);
-  glVertex2f(0, 0);
-  glVertex2f(SCREEN_WIDTH, 0);
-  glColor4f(bottom.red, bottom.green, bottom.blue, bottom.alpha);
-  glVertex2f(SCREEN_WIDTH, SCREEN_HEIGHT);
-  glVertex2f(0, SCREEN_HEIGHT);
-  glEnd();
-  glEnable(GL_TEXTURE_2D);
+  if(config->use_opengl)
+  {
+    glDisable(GL_TEXTURE_2D);
+    glBegin(GL_QUADS);
+    glColor4f(top.red, top.green, top.blue, top.alpha);
+    glVertex2f(0, 0);
+    glVertex2f(SCREEN_WIDTH, 0);
+    glColor4f(bottom.red, bottom.green, bottom.blue, bottom.alpha);
+    glVertex2f(SCREEN_WIDTH, SCREEN_HEIGHT);
+    glVertex2f(0, SCREEN_HEIGHT);
+    glEnd();
+    glEnable(GL_TEXTURE_2D);
+  }
+  else
+  {
+    for(int y = 0;y < screen->h;++y)
+    {
+      Uint8 r = (Uint8)((((float)(top.red-bottom.red)/(0-screen->h)) * y + top.red) * 255);
+      Uint8 g = (Uint8)((((float)(top.green-bottom.green)/(0-screen->h)) * y + top.green) * 255);
+      Uint8 b = (Uint8)((((float)(top.blue-bottom.blue)/(0-screen->h)) * y + top.blue) * 255);
+      Uint8 a = (Uint8)((((float)(top.alpha-bottom.alpha)/(0-screen->h)) * y + top.alpha) * 255);
+      Uint32 color = SDL_MapRGB(screen->format, r, g, b);
+
+      SDL_Rect rect;
+      rect.x = 0;
+      rect.y = y;
+      rect.w = screen->w;
+      rect.h = 1;
+
+      if(a == SDL_ALPHA_OPAQUE) {
+        SDL_FillRect(screen, &rect, color);
+      } else if(a != SDL_ALPHA_TRANSPARENT) {
+        SDL_Surface *temp = SDL_CreateRGBSurface(screen->flags, rect.w, rect.h, screen->format->BitsPerPixel, screen->format->Rmask, screen->format->Gmask, screen->format->Bmask, screen->format->Amask);
+
+        SDL_FillRect(temp, 0, color);
+        SDL_SetAlpha(temp, SDL_SRCALPHA, a);
+        SDL_BlitSurface(temp, 0, screen, &rect);
+        SDL_FreeSurface(temp);
+      }
+    }
+  }
   glColor4f(1, 1, 1, 1);
 }
 
@@ -398,22 +439,48 @@
   const FillRectRequest* fillrectrequest
     = (FillRectRequest*) request.request_data;
 
-  float x = request.pos.x;
-  float y = request.pos.y;
-  float w = fillrectrequest->size.x;
-  float h = fillrectrequest->size.y;
+  if(config->use_opengl)
+  {
+    float x = request.pos.x;
+    float y = request.pos.y;
+    float w = fillrectrequest->size.x;
+    float h = fillrectrequest->size.y;
 
-  glDisable(GL_TEXTURE_2D);
-  glColor4f(fillrectrequest->color.red, fillrectrequest->color.green,
-            fillrectrequest->color.blue, fillrectrequest->color.alpha);
+    glDisable(GL_TEXTURE_2D);
+    glColor4f(fillrectrequest->color.red, fillrectrequest->color.green,
+              fillrectrequest->color.blue, fillrectrequest->color.alpha);
 
-  glBegin(GL_QUADS);
-  glVertex2f(x, y);
-  glVertex2f(x+w, y);
-  glVertex2f(x+w, y+h);
-  glVertex2f(x, y+h);
-  glEnd();
-  glEnable(GL_TEXTURE_2D);
+    glBegin(GL_QUADS);
+    glVertex2f(x, y);
+    glVertex2f(x+w, y);
+    glVertex2f(x+w, y+h);
+    glVertex2f(x, y+h);
+    glEnd();
+    glEnable(GL_TEXTURE_2D);
+  }
+  else
+  {
+    SDL_Rect rect;
+    rect.x = (Sint16)request.pos.x;
+    rect.y = (Sint16)request.pos.y;
+    rect.w = (Uint16)fillrectrequest->size.x;
+    rect.h = (Uint16)fillrectrequest->size.y;
+    Uint8 r = static_cast<Uint8>(fillrectrequest->color.red * 255);
+    Uint8 g = static_cast<Uint8>(fillrectrequest->color.green * 255);
+    Uint8 b = static_cast<Uint8>(fillrectrequest->color.blue * 255);
+    Uint8 a = static_cast<Uint8>(fillrectrequest->color.alpha * 255);
+    Uint32 color = SDL_MapRGB(screen->format, r, g, b);
+    if(a == SDL_ALPHA_OPAQUE) {
+      SDL_FillRect(screen, &rect, color);
+    } else if(a != SDL_ALPHA_TRANSPARENT) {
+      SDL_Surface *temp = SDL_CreateRGBSurface(screen->flags, rect.w, rect.h, screen->format->BitsPerPixel, screen->format->Rmask, screen->format->Gmask, screen->format->Bmask, screen->format->Amask);
+
+      SDL_FillRect(temp, 0, color);
+      SDL_SetAlpha(temp, SDL_SRCALPHA, a);
+      SDL_BlitSurface(temp, 0, screen, &rect);
+      SDL_FreeSurface(temp);
+    }
+  }
   
   glColor4f(1, 1, 1, 1);
 }
@@ -462,29 +529,36 @@
 
   // PART1: create lightmap
   if(use_lightmap) {
-    glViewport(0, screen->h - lightmap_height, lightmap_width, lightmap_height);
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, -1.0, 1.0);
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
+    if(config->use_opengl)
+    {
+      glViewport(0, screen->h - lightmap_height, lightmap_width, lightmap_height);
+      glMatrixMode(GL_PROJECTION);
+      glLoadIdentity();
+      glOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, -1.0, 1.0);
+      glMatrixMode(GL_MODELVIEW);
+      glLoadIdentity();
 
-    glClearColor( ambient_color.red, ambient_color.green, ambient_color.blue, 1 );
-    glClear(GL_COLOR_BUFFER_BIT);
-    handle_drawing_requests(lightmap_requests);
-    lightmap_requests.clear();
+      glClearColor( ambient_color.red, ambient_color.green, ambient_color.blue, 1 );
+      glClear(GL_COLOR_BUFFER_BIT);
+      handle_drawing_requests(lightmap_requests);
+      lightmap_requests.clear();
 
-    glDisable(GL_BLEND);
-    glBindTexture(GL_TEXTURE_2D, lightmap->get_handle());
-    glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, screen->h - lightmap_height, lightmap_width, lightmap_height);
+      glDisable(GL_BLEND);
+      glBindTexture(GL_TEXTURE_2D, lightmap->get_handle());
+      glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, screen->h - lightmap_height, lightmap_width, lightmap_height);
 
-    glViewport(0, 0, screen->w, screen->h);
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, -1.0, 1.0);
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
-    glEnable(GL_BLEND);
+      glViewport(0, 0, screen->w, screen->h);
+      glMatrixMode(GL_PROJECTION);
+      glLoadIdentity();
+      glOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, -1.0, 1.0);
+      glMatrixMode(GL_MODELVIEW);
+      glLoadIdentity();
+      glEnable(GL_BLEND);
+    }
+    else
+    {
+      // FIXME: SDL alternative
+    }
 
     // add a lightmap drawing request into the queue
     DrawingRequest* request = new(obst) DrawingRequest();
@@ -499,7 +573,10 @@
   drawing_requests.clear();
   obstack_free(&obst, NULL);
   obstack_init(&obst);
-  assert_gl("drawing");
+  if(config->use_opengl)
+  {
+    assert_gl("drawing");
+  }
 
   // if a screenshot was requested, take one
   if (screenshot_requested) {
@@ -507,7 +584,14 @@
     screenshot_requested = false;
   }
 
-  SDL_GL_SwapBuffers();
+  if(config->use_opengl)
+  {
+    SDL_GL_SwapBuffers();
+  }
+  else
+  {
+    SDL_Flip(screen);
+  }
 }
 
 class RequestPtrCompare
@@ -644,36 +728,42 @@
 {
   // [Christoph] TODO: Yes, this method also takes care of the actual disk I/O. Split it?
 
-  // create surface to hold screenshot
-  #if SDL_BYTEORDER == SDL_BIG_ENDIAN
-  SDL_Surface* shot_surf = SDL_CreateRGBSurface(SDL_SWSURFACE, SCREEN_WIDTH, SCREEN_HEIGHT, 24, 0x00FF0000, 0x0000FF00, 0x000000FF, 0);
-  #else
-  SDL_Surface* shot_surf = SDL_CreateRGBSurface(SDL_SWSURFACE, SCREEN_WIDTH, SCREEN_HEIGHT, 24, 0x000000FF, 0x0000FF00, 0x00FF0000, 0);
-  #endif
-  if (!shot_surf) {
-    log_warning << "Could not create RGB Surface to contain screenshot" << std::endl;
-    return;
-  }
+  SDL_Surface *shot_surf;
+  if(config->use_opengl) {
+    // create surface to hold screenshot
+    #if SDL_BYTEORDER == SDL_BIG_ENDIAN
+    shot_surf = SDL_CreateRGBSurface(SDL_SWSURFACE, SCREEN_WIDTH, SCREEN_HEIGHT, 24, 0x00FF0000, 0x0000FF00, 0x000000FF, 0);
+    #else
+    shot_surf = SDL_CreateRGBSurface(SDL_SWSURFACE, SCREEN_WIDTH, SCREEN_HEIGHT, 24, 0x000000FF, 0x0000FF00, 0x00FF0000, 0);
+    #endif
+    if (!shot_surf) {
+      log_warning << "Could not create RGB Surface to contain screenshot" << std::endl;
+      return;
+    }
 
-  // read pixels into array
-  char* pixels = new char[3 * SCREEN_WIDTH * SCREEN_HEIGHT];
-  if (!pixels) {
-    log_warning << "Could not allocate memory to store screenshot" << std::endl;
-    SDL_FreeSurface(shot_surf);
-    return;
-  }
-  glReadPixels(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, GL_RGB, GL_UNSIGNED_BYTE, pixels);
+    // read pixels into array
+    char* pixels = new char[3 * SCREEN_WIDTH * SCREEN_HEIGHT];
+    if (!pixels) {
+      log_warning << "Could not allocate memory to store screenshot" << std::endl;
+      SDL_FreeSurface(shot_surf);
+      return;
+    }
+    glReadPixels(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, GL_RGB, GL_UNSIGNED_BYTE, pixels);
 
-  // copy array line-by-line
-  for (int i = 0; i < SCREEN_HEIGHT; i++) {
-    char* src = pixels + (3 * SCREEN_WIDTH * (SCREEN_HEIGHT - i - 1));
-    char* dst = ((char*)shot_surf->pixels) + i * shot_surf->pitch;
-    memcpy(dst, src, 3 * SCREEN_WIDTH);
+    // copy array line-by-line
+    for (int i = 0; i < SCREEN_HEIGHT; i++) {
+      char* src = pixels + (3 * SCREEN_WIDTH * (SCREEN_HEIGHT - i - 1));
+      char* dst = ((char*)shot_surf->pixels) + i * shot_surf->pitch;
+      memcpy(dst, src, 3 * SCREEN_WIDTH);
+    }
+
+    // free array
+    delete[](pixels);
+  } else {
+    shot_surf = SDL_GetVideoSurface();
+    shot_surf->refcount++;
   }
 
-  // free array
-  delete[](pixels);
-
   // save screenshot
   static const std::string writeDir = PHYSFS_getWriteDir();
   static const std::string dirSep = PHYSFS_getDirSeparator();
Index: src/video/texture.cpp
===================================================================
--- src/video/texture.cpp	(revision 5067)
+++ src/video/texture.cpp	(working copy)
@@ -20,6 +20,7 @@
 #include <config.h>
 
 #include "texture.hpp"
+#include "gameconfig.hpp"
 
 #include <GL/gl.h>
 #include <assert.h>
@@ -34,24 +35,32 @@
 {
   assert(is_power_of_2(w));
   assert(is_power_of_2(h));
+  use_opengl = config->use_opengl;
 
-  this->width = w;
-  this->height = h;
+  if(use_opengl)
+  {
+    surface.opengl.width = w;
+    surface.opengl.height = h;
 
-  assert_gl("before creating texture");
-  glGenTextures(1, &handle);
+    assert_gl("before creating texture");
+    glGenTextures(1, &surface.opengl.handle);
 
-  try {
-    glBindTexture(GL_TEXTURE_2D, handle);
+    try {
+      glBindTexture(GL_TEXTURE_2D, surface.opengl.handle);
 
-    glTexImage2D(GL_TEXTURE_2D, 0, glformat, width, height, 0, GL_RGBA,
-                 GL_UNSIGNED_BYTE, 0);
+      glTexImage2D(GL_TEXTURE_2D, 0, glformat, surface.opengl.width,
+                   surface.opengl.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
 
-    set_texture_params();
-  } catch(...) {
-    glDeleteTextures(1, &handle);
-    throw;
+      set_texture_params();
+    } catch(...) {
+      glDeleteTextures(1, &surface.opengl.handle);
+      throw;
+    }
   }
+  else
+  {
+    surface.sdl = 0;
+  }
 }
 
 Texture::Texture(SDL_Surface* image, GLenum glformat)
@@ -61,49 +70,62 @@
     throw std::runtime_error("image has no power of 2 size");
   if(format->BitsPerPixel != 24 && format->BitsPerPixel != 32)
     throw std::runtime_error("image has no 24 or 32 bit color depth");
+  use_opengl = config->use_opengl;
 
-  this->width = image->w;
-  this->height = image->h;
+  if(use_opengl)
+  {
+    surface.opengl.width = image->w;
+    surface.opengl.height = image->h;
 
-  assert_gl("before creating texture");
-  glGenTextures(1, &handle);
+    assert_gl("before creating texture");
+    glGenTextures(1, &surface.opengl.handle);
 
-  try {
-    GLenum sdl_format;
-    if(format->BytesPerPixel == 3)
-      sdl_format = GL_RGB;
-    else if(format->BytesPerPixel == 4)
-      sdl_format = GL_RGBA;
-    else
-      assert(false);
+    try {
+      GLenum sdl_format;
+      if(format->BytesPerPixel == 3)
+        sdl_format = GL_RGB;
+      else if(format->BytesPerPixel == 4)
+        sdl_format = GL_RGBA;
+      else
+        assert(false);
 
-    glBindTexture(GL_TEXTURE_2D, handle);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, image->pitch/format->BytesPerPixel);
-    glTexImage2D(GL_TEXTURE_2D, 0, glformat, width, height, 0, sdl_format,
-            GL_UNSIGNED_BYTE, image->pixels);
+      glBindTexture(GL_TEXTURE_2D, surface.opengl.handle);
+      glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+      glPixelStorei(GL_UNPACK_ROW_LENGTH, image->pitch/format->BytesPerPixel);
+      glTexImage2D(GL_TEXTURE_2D, 0, glformat, surface.opengl.width,
+              surface.opengl.height, 0, sdl_format,
+              GL_UNSIGNED_BYTE, image->pixels);
 
-    assert_gl("creating texture");
+      assert_gl("creating texture");
 
-    set_texture_params();
-  } catch(...) {
-    glDeleteTextures(1, &handle);
-    throw;
+      set_texture_params();
+    } catch(...) {
+      glDeleteTextures(1, &surface.opengl.handle);
+      throw;
+    }
+  } else {
+    surface.sdl = SDL_DisplayFormatAlpha(image);
   }
 }
 
 Texture::~Texture()
 {
-  glDeleteTextures(1, &handle);
+  if(use_opengl) {
+    glDeleteTextures(1, &surface.opengl.handle);
+  } else {
+    SDL_FreeSurface(surface.sdl);
+  }
 }
 
 void
 Texture::set_texture_params()
 {
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  if(use_opengl) {
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 
-  assert_gl("set texture params");
+    assert_gl("set texture params");
+  }
 }
Index: src/video/texture.hpp
===================================================================
--- src/video/texture.hpp	(revision 5067)
+++ src/video/texture.hpp	(working copy)
@@ -20,9 +20,13 @@
 #ifndef __TEXTURE_HPP__
 #define __TEXTURE_HPP__
 
+#include <assert.h>
+
 #include <SDL.h>
 #include <GL/gl.h>
 
+#include "gameconfig.hpp"
+
 /**
  * This class is a wrapper around a texture handle. It stores the texture width
  * and height and provides convenience functions for uploading SDL_Surfaces
@@ -31,29 +35,57 @@
 class Texture
 {
 protected:
-  friend class TextureManager;
-  GLuint handle;
-  unsigned int width;
-  unsigned int height;
+  bool use_opengl;
+  union {
+    struct {
+      GLuint handle;
+      unsigned int width;
+      unsigned int height;
+    } opengl;
+    SDL_Surface *sdl;
+  } surface;
 
 public:
   Texture(unsigned int width, unsigned int height, GLenum glformat);
-  Texture(SDL_Surface* surface, GLenum glformat);
+  Texture(SDL_Surface* sdlsurface, GLenum glformat);
   virtual ~Texture();
 
-  GLuint get_handle() const
-  {
-    return handle;
+  const GLuint &get_handle() const {
+    assert(use_opengl);
+    return surface.opengl.handle;
   }
 
+  void set_handle(GLuint handle) {
+    assert(use_opengl);
+    surface.opengl.handle = handle;
+  }
+
+  SDL_Surface *get_surface() const {
+    assert(!use_opengl);
+    return surface.sdl;
+  }
+
+  void set_surface(SDL_Surface *sdlsurface) {
+    assert(!use_opengl);
+    surface.sdl = sdlsurface;
+  }
+
   unsigned int get_width() const
   {
-    return width;
+    if(use_opengl) {
+      return surface.opengl.width;
+    } else {
+      return surface.sdl->w;
+    }
   }
 
   unsigned int get_height() const
   {
-    return height;
+    if(use_opengl) {
+      return surface.opengl.height;
+    } else {
+      return surface.sdl->h;
+    }
   }
 
 private:
Index: src/video/surface.cpp
===================================================================
--- src/video/surface.cpp	(revision 5067)
+++ src/video/surface.cpp	(working copy)
@@ -41,13 +41,27 @@
 {
   texture = texture_manager->get(file);
   texture->ref();
-  uv_left = 0;
-  uv_top = 0;
-  uv_right = texture->get_uv_right();
-  uv_bottom = texture->get_uv_bottom();
 
-  width = texture->get_image_width();
-  height = texture->get_image_height();
+  use_opengl = config->use_opengl;
+
+  if(use_opengl) {
+    surface.opengl.uv_left = 0;
+    surface.opengl.uv_top = 0;
+    surface.opengl.uv_right = texture->get_uv_right();
+    surface.opengl.uv_bottom = texture->get_uv_bottom();
+
+    surface.opengl.width = texture->get_image_width();
+    surface.opengl.height = texture->get_image_height();
+  } else {
+    memset(transforms, 0, NUM_EFFECTS * sizeof(SDL_Surface *));
+
+    surface.sdl.offsetx = 0;
+    surface.sdl.offsety = 0;
+    surface.sdl.width = static_cast<int>(texture->get_image_width());
+    surface.sdl.height = static_cast<int>(texture->get_image_height());
+
+    surface.sdl.flipx = false;
+  }
 }
 
 Surface::Surface(const std::string& file, int x, int y, int w, int h)
@@ -55,15 +69,28 @@
   texture = texture_manager->get(file);
   texture->ref();
 
-  float tex_w = static_cast<float> (texture->get_width());
-  float tex_h = static_cast<float> (texture->get_height());
-  uv_left = static_cast<float>(x) / tex_w;
-  uv_top = static_cast<float>(y) / tex_h;
-  uv_right = static_cast<float>(x+w) / tex_w;
-  uv_bottom = static_cast<float>(y+h) / tex_h;
+  use_opengl = config->use_opengl;
 
-  width = w;
-  height = h;
+  if(use_opengl) {
+    float tex_w = static_cast<float> (texture->get_width());
+    float tex_h = static_cast<float> (texture->get_height());
+    surface.opengl.uv_left = static_cast<float>(x) / tex_w;
+    surface.opengl.uv_top = static_cast<float>(y) / tex_h;
+    surface.opengl.uv_right = static_cast<float>(x+w) / tex_w;
+    surface.opengl.uv_bottom = static_cast<float>(y+h) / tex_h;
+
+    surface.opengl.width = w;
+    surface.opengl.height = h;
+  } else {
+    memset(transforms, 0, NUM_EFFECTS * sizeof(SDL_Surface *));
+
+    surface.sdl.offsetx = x;
+    surface.sdl.offsety = y;
+    surface.sdl.width = w;
+    surface.sdl.height = h;
+
+    surface.sdl.flipx = false;
+  }
 }
 
 Surface::Surface(const Surface& other)
@@ -71,12 +98,25 @@
   texture = other.texture;
   texture->ref();
 
-  uv_left = other.uv_left;
-  uv_top = other.uv_top;
-  uv_right = other.uv_right;
-  uv_bottom = other.uv_bottom;
-  width = other.width;
-  height = other.height;
+  use_opengl = config->use_opengl;
+
+  if(use_opengl) {
+    surface.opengl.uv_left = other.surface.opengl.uv_left;
+    surface.opengl.uv_top = other.surface.opengl.uv_top;
+    surface.opengl.uv_right = other.surface.opengl.uv_right;
+    surface.opengl.uv_bottom = other.surface.opengl.uv_bottom;
+    surface.opengl.width = other.surface.opengl.width;
+    surface.opengl.height = other.surface.opengl.height;
+  } else {
+    memset(transforms, 0, NUM_EFFECTS * sizeof(SDL_Surface *));
+
+    surface.sdl.offsetx = other.surface.sdl.offsetx;
+    surface.sdl.offsety = other.surface.sdl.offsety;
+    surface.sdl.width = other.surface.sdl.width;
+    surface.sdl.height = other.surface.sdl.height;
+
+    surface.sdl.flipx = other.surface.sdl.flipx;
+  }
 }
 
 const Surface&
@@ -86,25 +126,46 @@
   texture->unref();
   texture = other.texture;
 
-  uv_left = other.uv_left;
-  uv_top = other.uv_top;
-  uv_right = other.uv_right;
-  uv_bottom = other.uv_bottom;
-  width = other.width;
-  height = other.height;
+  use_opengl = config->use_opengl;
 
+  if(use_opengl) {
+    surface.opengl.uv_left = other.surface.opengl.uv_left;
+    surface.opengl.uv_top = other.surface.opengl.uv_top;
+    surface.opengl.uv_right = other.surface.opengl.uv_right;
+    surface.opengl.uv_bottom = other.surface.opengl.uv_bottom;
+    surface.opengl.width = other.surface.opengl.width;
+    surface.opengl.height = other.surface.opengl.height;
+  } else {
+    memset(transforms, 0, NUM_EFFECTS * sizeof(SDL_Surface *));
+
+    surface.sdl.offsetx = other.surface.sdl.offsetx;
+    surface.sdl.offsety = other.surface.sdl.offsety;
+    surface.sdl.width = other.surface.sdl.width;
+    surface.sdl.height = other.surface.sdl.height;
+
+    surface.sdl.flipx = other.surface.sdl.flipx;
+  }
+
   return *this;
 }
 
 Surface::~Surface()
 {
   texture->unref();
+
+  if(!use_opengl) {
+    std::for_each(transforms, transforms + NUM_EFFECTS, SDL_FreeSurface);
+  }
 }
 
 void
 Surface::hflip()
 {
-  std::swap(uv_left, uv_right);
+  if(use_opengl) {
+    std::swap(surface.opengl.uv_left, surface.opengl.uv_right);
+  } else {
+    surface.sdl.flipx = !surface.sdl.flipx;
+  }
 }
 
 static inline void intern_draw(float left, float top, float right, float bottom,                               float uv_left, float uv_top,
@@ -186,28 +247,99 @@
 void
 Surface::draw(float x, float y, float alpha, float angle, const Color& color, const Blend& blend, DrawingEffect effect) const
 {
-  glBindTexture(GL_TEXTURE_2D, texture->get_handle());
-
-  intern_draw2(x, y,
-               x + width, y + height,
-               uv_left, uv_top, uv_right, uv_bottom,
-               angle,
-               alpha,
-               color,
-               blend,
-               effect);
+  if(use_opengl) {
+    glBindTexture(GL_TEXTURE_2D, texture->get_handle());
+    intern_draw2(x, y,
+                 x + surface.opengl.width, y + surface.opengl.height,
+                 surface.opengl.uv_left, surface.opengl.uv_top,
+                 surface.opengl.uv_right, surface.opengl.uv_bottom,
+                 angle,
+                 alpha,
+                 color,
+                 blend,
+                 effect);
+  } else {
+    draw_part(0, 0, x, y, surface.sdl.width, surface.sdl.height, alpha, effect);
+  }
 }
 
 void
 Surface::draw(float x, float y, float alpha, DrawingEffect effect) const
 {
-  glBindTexture(GL_TEXTURE_2D, texture->get_handle());
+  if(use_opengl) {
+    glBindTexture(GL_TEXTURE_2D, texture->get_handle());
+    glColor4f(1, 1, 1, alpha);
+    intern_draw(x, y,
+                x + surface.opengl.width, y + surface.opengl.height,
+                surface.opengl.uv_left, surface.opengl.uv_top,
+                surface.opengl.uv_right, surface.opengl.uv_bottom, effect);
+    glColor4f(1, 1, 1, 1);
+  } else {
+    draw_part(0, 0, x, y, surface.sdl.width, surface.sdl.height, alpha, effect);
+  }
+}
 
-  glColor4f(1, 1, 1, alpha);
-  intern_draw(x, y,
-              x + width, y + height,
-              uv_left, uv_top, uv_right, uv_bottom, effect);
-  glColor4f(1, 1, 1, 1);
+namespace
+{
+  SDL_Surface *horz_flip(SDL_Surface *src)
+  {
+    SDL_Surface *dst = SDL_ConvertSurface(src, src->format, src->flags);
+    int bpp = dst->format->BytesPerPixel;
+    for(int y = 0;y < dst->h;y++) {
+      Uint8 *line = (Uint8 *) dst->pixels + y * dst->pitch;
+      for(int x = 0;x < (dst->w / 2);x++) {
+        switch(bpp) {
+          case 4:
+            line[3 + x * bpp] ^= line[3 + (dst->w - x - 1) * bpp];
+            line[3 + (dst->w - x - 1) * bpp] ^= line[3 + x * bpp];
+            line[3 + x * bpp] ^= line[3 + (dst->w - x - 1) * bpp];
+          case 3:
+            line[2 + x * bpp] ^= line[2 + (dst->w - x - 1) * bpp];
+            line[2 + (dst->w - x - 1) * bpp] ^= line[2 + x * bpp];
+            line[2 + x * bpp] ^= line[2 + (dst->w - x - 1) * bpp];
+          case 2:
+            line[1 + x * bpp] ^= line[1 + (dst->w - x - 1) * bpp];
+            line[1 + (dst->w - x - 1) * bpp] ^= line[1 + x * bpp];
+            line[1 + x * bpp] ^= line[1 + (dst->w - x - 1) * bpp];
+          case 1:
+            line[0 + x * bpp] ^= line[0 + (dst->w - x - 1) * bpp];
+            line[0 + (dst->w - x - 1) * bpp] ^= line[0 + x * bpp];
+            line[0 + x * bpp] ^= line[0 + (dst->w - x - 1) * bpp];
+        }
+      }
+    }
+    return dst;
+  }
+
+  SDL_Surface *vert_flip(SDL_Surface *src)
+  {
+    SDL_Surface *dst = SDL_ConvertSurface(src, src->format, src->flags);
+    int bpp = dst->format->BytesPerPixel;
+    for(int x = 0;x < dst->w;x++) {
+      Uint8 *rank = (Uint8 *) dst->pixels + x * bpp;
+      for(int y = 0;y < (dst->h / 2);y++) {
+        switch(bpp) {
+          case 4:
+            rank[3 + y * dst->pitch] ^= rank[3 + (dst->h - y - 1) * dst->pitch];
+            rank[3 + (dst->h - y - 1) * dst->pitch] ^= rank[3 + y * dst->pitch];
+            rank[3 + y * dst->pitch] ^= rank[3 + (dst->h - y - 1) * dst->pitch];
+          case 3:
+            rank[2 + y * dst->pitch] ^= rank[2 + (dst->h - y - 1) * dst->pitch];
+            rank[2 + (dst->h - y - 1) * dst->pitch] ^= rank[2 + y * dst->pitch];
+            rank[2 + y * dst->pitch] ^= rank[2 + (dst->h - y - 1) * dst->pitch];
+          case 2:
+            rank[1 + y * dst->pitch] ^= rank[1 + (dst->h - y - 1) * dst->pitch];
+            rank[1 + (dst->h - y - 1) * dst->pitch] ^= rank[1 + y * dst->pitch];
+            rank[1 + y * dst->pitch] ^= rank[1 + (dst->h - y - 1) * dst->pitch];
+          case 1:
+            rank[0 + y * dst->pitch] ^= rank[0 + (dst->h - y - 1) * dst->pitch];
+            rank[0 + (dst->h - y - 1) * dst->pitch] ^= rank[0 + y * dst->pitch];
+            rank[0 + y * dst->pitch] ^= rank[0 + (dst->h - y - 1) * dst->pitch];
+        }
+      }
+    }
+    return dst;
+  }
 }
 
 void
@@ -215,19 +347,65 @@
                    float width, float height, float alpha,
                    DrawingEffect effect) const
 {
-  float uv_width = uv_right - uv_left;
-  float uv_height = uv_bottom - uv_top;
+  if(use_opengl) {
+    float uv_width = surface.opengl.uv_right - surface.opengl.uv_left;
+    float uv_height = surface.opengl.uv_bottom - surface.opengl.uv_top;
 
-  float uv_left = this->uv_left + (uv_width * src_x) / this->width;
-  float uv_top = this->uv_top + (uv_height * src_y) / this->height;
-  float uv_right = this->uv_left + (uv_width * (src_x + width)) / this->width;
-  float uv_bottom = this->uv_top + (uv_height * (src_y + height)) / this->height;
+    float uv_left = surface.opengl.uv_left + (uv_width * src_x) / surface.opengl.width;
+    float uv_top = surface.opengl.uv_top + (uv_height * src_y) / surface.opengl.height;
+    float uv_right = surface.opengl.uv_left + (uv_width * (src_x + width)) / surface.opengl.width;
+    float uv_bottom = surface.opengl.uv_top + (uv_height * (src_y + height)) / surface.opengl.height;
 
-  glBindTexture(GL_TEXTURE_2D, texture->get_handle());
+    glBindTexture(GL_TEXTURE_2D, texture->get_handle());
+    glColor4f(1, 1, 1, alpha);
+    intern_draw(dst_x, dst_y,
+                dst_x + width, dst_y + height,
+                uv_left, uv_top, uv_right, uv_bottom, effect);
+    glColor4f(1, 1, 1, 1);
+  } else {
+    //FIXME: support parameter "alpha"
+ 
+    // get and check SDL_Surface
+    if (texture->get_surface() == 0) {
+      std::cerr << "Warning: Tried to draw NULL surface, skipped draw" << std::endl;
+      return;
+    }	
 
-  glColor4f(1, 1, 1, alpha);
-  intern_draw(dst_x, dst_y,
-              dst_x + width, dst_y + height,
-              uv_left, uv_top, uv_right, uv_bottom, effect);
-  glColor4f(1, 1, 1, 1);
+    if (surface.sdl.flipx) effect = HORIZONTAL_FLIP;
+
+    if(transforms[effect] == 0) {
+      switch(effect) {
+        case NO_EFFECT:
+          transforms[NO_EFFECT] = texture->get_surface();
+          transforms[NO_EFFECT]->refcount++;
+          break;
+        case HORIZONTAL_FLIP:
+          transforms[HORIZONTAL_FLIP] = horz_flip(texture->get_surface());
+          break;
+        case VERTICAL_FLIP:
+          transforms[VERTICAL_FLIP] = vert_flip(texture->get_surface());
+          break;
+        default:
+          std::cerr << "Warning: No known transformation applies to surface, skipped draw" << std::endl;
+          return;
+      }
+    }
+
+    int ox = surface.sdl.offsetx; if (effect == HORIZONTAL_FLIP) ox = static_cast<int>(transforms[effect]->w) - (ox+static_cast<int>(width));
+    int oy = surface.sdl.offsety; if (effect == VERTICAL_FLIP) oy = static_cast<int>(transforms[effect]->h) - (oy+static_cast<int>(height));
+    // draw surface to screen
+    SDL_Surface* screen = SDL_GetVideoSurface();
+
+    SDL_Rect srcRect;
+    srcRect.x = static_cast<int>(ox+src_x);
+    srcRect.y = static_cast<int>(oy+src_y);
+    srcRect.w = static_cast<int>(width);
+    srcRect.h = static_cast<int>(height);
+
+    SDL_Rect dstRect;
+    dstRect.x = static_cast<int>(dst_x);
+    dstRect.y = static_cast<int>(dst_y);
+
+    SDL_BlitSurface(transforms[effect], &srcRect, screen, &dstRect);
+  }
 }
Index: src/video/texture_manager.cpp
===================================================================
--- src/video/texture_manager.cpp	(revision 5067)
+++ src/video/texture_manager.cpp	(working copy)
@@ -32,6 +32,7 @@
 #include "physfs/physfs_sdl.hpp"
 #include "image_texture.hpp"
 #include "glutil.hpp"
+#include "gameconfig.hpp"
 #include "file_system.hpp"
 #include "log.hpp"
 
@@ -149,12 +150,14 @@
 void
 TextureManager::save_textures()
 {
-  glPixelStorei(GL_PACK_ROW_LENGTH, 0);
-  glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
-  glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
-  glPixelStorei(GL_PACK_SKIP_ROWS, 0);
-  glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
-  glPixelStorei(GL_PACK_ALIGNMENT, 1);
+  if(config->use_opengl) {
+    glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
+    glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
+    glPixelStorei(GL_PACK_ALIGNMENT, 1);
+  }
   for(Textures::iterator i = textures.begin(); i != textures.end(); ++i) {
     save_texture(*i);
   }
@@ -169,73 +172,81 @@
 {
   SavedTexture saved_texture;
   saved_texture.texture = texture;
-  glBindTexture(GL_TEXTURE_2D, texture->get_handle());
-  glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH,
-                           &saved_texture.width);
-  glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT,
-                           &saved_texture.height);
-  glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_BORDER,
-                           &saved_texture.border);
-  glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
-                      &saved_texture.min_filter);
-  glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
-                      &saved_texture.mag_filter);
-  glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
-                      &saved_texture.wrap_s);
-  glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
-                      &saved_texture.wrap_t);
+  if(config->use_opengl) {
+    glBindTexture(GL_TEXTURE_2D, texture->get_handle());
+    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH,
+                             &saved_texture.width);
+    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT,
+                             &saved_texture.height);
+    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_BORDER,
+                             &saved_texture.border);
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+                        &saved_texture.min_filter);
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+                        &saved_texture.mag_filter);
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
+                        &saved_texture.wrap_s);
+    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
+                        &saved_texture.wrap_t);
+  }
 
   size_t pixelssize = saved_texture.width * saved_texture.height * 4;
   saved_texture.pixels = new char[pixelssize];
 
-  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE,
-                saved_texture.pixels);
+  if(config->use_opengl) {
+    glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+                  saved_texture.pixels);
+  }
 
   saved_textures.push_back(saved_texture);
 
-  glDeleteTextures(1, &(texture->handle));
-  texture->handle = 0;
+  if(config->use_opengl) {
+    glDeleteTextures(1, &(texture->get_handle()));
+    texture->set_handle(0);
 
-  assert_gl("retrieving texture for save");
+    assert_gl("retrieving texture for save");
+  }
 }
 
 void
 TextureManager::reload_textures()
 {
-  glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
-  glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0);
-  glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
-  glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
-  glPixelStorei(GL_UNPACK_SKIP_IMAGES, 0);
-  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+  if(config->use_opengl) {
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+    glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0);
+    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
+    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
+    glPixelStorei(GL_UNPACK_SKIP_IMAGES, 0);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 
-  for(std::vector<SavedTexture>::iterator i = saved_textures.begin();
-      i != saved_textures.end(); ++i) {
-    SavedTexture& saved_texture = *i;
+    for(std::vector<SavedTexture>::iterator i = saved_textures.begin();
+        i != saved_textures.end(); ++i) {
+      SavedTexture& saved_texture = *i;
 
-    GLuint handle;
-    glGenTextures(1, &handle);
-    assert_gl("creating texture handle");
+      GLuint handle;
+      glGenTextures(1, &handle);
+      assert_gl("creating texture handle");
 
-    glBindTexture(GL_TEXTURE_2D, handle);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
-                 saved_texture.width, saved_texture.height,
-                 saved_texture.border, GL_RGBA,
-                 GL_UNSIGNED_BYTE, saved_texture.pixels);
-    delete[] saved_texture.pixels;
-    assert_gl("uploading texture pixel data");
+      glBindTexture(GL_TEXTURE_2D, handle);
+      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+                   saved_texture.width, saved_texture.height,
+                   saved_texture.border, GL_RGBA,
+                   GL_UNSIGNED_BYTE, saved_texture.pixels);
+      delete[] saved_texture.pixels;
+      assert_gl("uploading texture pixel data");
 
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
-                    saved_texture.min_filter);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
-                    saved_texture.mag_filter);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
-                    saved_texture.wrap_s);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
-                    saved_texture.wrap_t);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+                      saved_texture.min_filter);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+                      saved_texture.mag_filter);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
+                      saved_texture.wrap_s);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
+                      saved_texture.wrap_t);
 
-    assert_gl("setting texture_params");
-    saved_texture.texture->handle = handle;
+      assert_gl("setting texture_params");
+      saved_texture.texture->set_handle(handle);
+    }
   }
 
   saved_textures.clear();
Index: src/video/surface.hpp
===================================================================
--- src/video/surface.hpp	(revision 5067)
+++ src/video/surface.hpp	(working copy)
@@ -21,6 +21,8 @@
 #define __SURFACE_HPP__
 
 #include <string>
+#include <SDL.h>
+#include "gameconfig.hpp"
 #include "math/vector.hpp"
 
 class Color;
@@ -30,11 +32,12 @@
 /// bitset for drawing effects
 enum DrawingEffect {
   /** Don't apply anything */
-  NO_EFFECT       = 0x0000,
+  NO_EFFECT,
   /** Draw the Surface upside down */
-  VERTICAL_FLIP     = 0x0001,
+  VERTICAL_FLIP,
   /** Draw the Surface from left to down */
-  HORIZONTAL_FLIP   = 0x0002,
+  HORIZONTAL_FLIP,
+  NUM_EFFECTS
 };
 
 /**
@@ -47,21 +50,38 @@
 private:
   friend class DrawingContext;
   friend class Font;
-  ImageTexture* texture;
 
-  float uv_left;
-  float uv_top;
-  float uv_right;
-  float uv_bottom;
-
   void draw(float x, float y, float alpha, float angle, const Color& color, const Blend& blend, DrawingEffect effect) const;
   void draw(float x, float y, float alpha, DrawingEffect effect) const;
   void draw_part(float src_x, float src_y, float dst_x, float dst_y,
                  float width, float height,
                  float alpha, DrawingEffect effect) const;
 
-  float width;
-  float height;
+  ImageTexture* texture;
+  bool use_opengl;
+  union
+  {
+    struct
+    {
+      float uv_left;
+      float uv_top;
+      float uv_right;
+      float uv_bottom;
+
+      float width;
+      float height;
+    } opengl;
+    struct
+    {
+      bool flipx;
+      int offsetx; /**< Region in ::surface to be used for blitting */
+      int offsety; /**< Region in ::surface to be used for blitting */
+      int width;   /**< Region in ::surface to be used for blitting */
+      int height;  /**< Region in ::surface to be used for blitting */
+    } sdl;
+  } surface;
+  mutable SDL_Surface *transforms[NUM_EFFECTS]; /**< Cache for pre-transformed surfaces */
+
 public:
   Surface(const std::string& file);
   Surface(const std::string& file, int x, int y, int w, int h);
@@ -75,12 +95,20 @@
 
   float get_width() const
   {
-    return width;
+    if(use_opengl) {
+      return surface.opengl.width;
+    } else {
+      return surface.sdl.width;
+    }
   }
 
   float get_height() const
   {
-    return height;
+    if(use_opengl) {
+      return surface.opengl.height;
+    } else {
+      return surface.sdl.height;
+    }
   }
 
   /**
Index: src/gameconfig.cpp
===================================================================
--- src/gameconfig.cpp	(revision 5067)
+++ src/gameconfig.cpp	(working copy)
@@ -36,6 +36,7 @@
 Config::Config()
 {
   use_fullscreen = true;
+  use_opengl = true;
   try_vsync = true;
   show_fps = false;
   sound_enabled = true;
@@ -70,7 +71,8 @@
   const lisp::Lisp* config_video_lisp = config_lisp->get_lisp("video");
   if(config_video_lisp) {
     config_video_lisp->get("fullscreen", use_fullscreen);
-	config_video_lisp->get("vsync", try_vsync);
+    config_video_lisp->get("opengl", use_opengl);
+    config_video_lisp->get("vsync", try_vsync);
     config_video_lisp->get("width", screenwidth);
     config_video_lisp->get("height", screenheight);
     config_video_lisp->get("aspect_ratio", aspect_ratio);
@@ -100,6 +102,7 @@
 
   writer.start_list("video");
   writer.write_bool("fullscreen", use_fullscreen);
+  writer.write_bool("opengl", use_opengl);
   writer.write_bool("vsync", try_vsync);
   writer.write_int("width", screenwidth);
   writer.write_int("height", screenheight);
Index: src/main.cpp
===================================================================
--- src/main.cpp	(revision 5067)
+++ src/main.cpp	(working copy)
@@ -383,7 +383,7 @@
   SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 5);
   SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 5);
 
-  int flags = SDL_OPENGL;
+  int flags = config->use_opengl ? SDL_OPENGL : SDL_SWSURFACE;
   if(config->use_fullscreen)
     flags |= SDL_FULLSCREEN;
   int width = config->screenwidth;
@@ -437,23 +437,26 @@
 
   log_info << (config->use_fullscreen?"fullscreen ":"window ") << SCREEN_WIDTH << "x" << SCREEN_HEIGHT << " Ratio: " << aspect_ratio << "\n";
 
-  // setup opengl state and transform
-  glDisable(GL_DEPTH_TEST);
-  glDisable(GL_CULL_FACE);
-  glEnable(GL_TEXTURE_2D);
-  glEnable(GL_BLEND);
-  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  if(config->use_opengl)
+  {
+    // setup opengl state and transform
+    glDisable(GL_DEPTH_TEST);
+    glDisable(GL_CULL_FACE);
+    glEnable(GL_TEXTURE_2D);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-  glViewport(0, 0, screen->w, screen->h);
-  glMatrixMode(GL_PROJECTION);
-  glLoadIdentity();
-  // logical resolution here not real monitor resolution
-  glOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, -1.0, 1.0);
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
-  glTranslatef(0, 0, 0);
+    glViewport(0, 0, screen->w, screen->h);
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    // logical resolution here not real monitor resolution
+    glOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, -1.0, 1.0);
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    glTranslatef(0, 0, 0);
 
-  check_gl_error("Setting up view matrices");
+    check_gl_error("Setting up view matrices");
+  }
 
   if(texture_manager != NULL)
     texture_manager->reload_textures();
